using HCILibrary.HCIRequests;
using HCILibrary.Helpers;

namespace HCILibrary.HCIResponses;

/// <summary>
/// Represents a crosspoint level entry in a Reply Crosspoint Level Status message.
/// </summary>
public class CrosspointLevelStatus
{
    /// <summary>
    /// The destination port number (0-1023).
    /// </summary>
    public ushort DestinationPort { get; set; }

    /// <summary>
    /// The source port number (0-1023).
    /// </summary>
    public ushort SourcePort { get; set; }

    /// <summary>
    /// The level value (0-287).
    /// </summary>
    public ushort LevelValue { get; set; }

    /// <summary>
    /// Gets the gain in dB for this crosspoint.
    /// </summary>
    public double GainDb => GainLevel.LevelToDb(LevelValue);

    /// <summary>
    /// Gets a formatted string of the gain level.
    /// </summary>
    public string FormattedGain => GainLevel.FormatLevel(LevelValue);

    public override string ToString()
    {
        return $"Src:{SourcePort} -> Dst:{DestinationPort} @ {FormattedGain}";
    }
}

/// <summary>
/// Reply Crosspoint Level Status (HCIv2) - Message ID 0x0028.
/// Contains a list of all the HCI applied crosspoint level adjustments for a specified destination.
/// Generated by the matrix in response to a Request Crosspoint Level Action or
/// Crosspoint Level Status message.
/// </summary>
public class ReplyCrosspointLevelStatus
{
    /// <summary>
    /// The list of crosspoint level entries.
    /// </summary>
    public List<CrosspointLevelStatus> Levels { get; } = new();

    /// <summary>
    /// Decodes a Reply Crosspoint Level Status from the payload bytes.
    /// </summary>
    /// <param name="payload">The payload bytes (after protocol tag and schema).</param>
    /// <returns>The decoded reply, or null if invalid.</returns>
    public static ReplyCrosspointLevelStatus? Decode(byte[] payload)
    {
        // Minimum: Count(2) = 2 bytes
        if (payload == null || payload.Length < 2)
        {
            return null;
        }

        var reply = new ReplyCrosspointLevelStatus();
        int offset = 0;

        // Count: 16 bit word (big-endian)
        ushort count = (ushort)((payload[offset] << 8) | payload[offset + 1]);
        offset += 2;

        // Each entry: DestPort(2) + SrcPort(2) + Level(2) = 6 bytes
        for (int i = 0; i < count && offset + 6 <= payload.Length; i++)
        {
            var entry = new CrosspointLevelStatus();

            // Destination Port: 16 bit word (big-endian)
            entry.DestinationPort = (ushort)((payload[offset] << 8) | payload[offset + 1]);
            offset += 2;

            // Source Port: 16 bit word (big-endian)
            entry.SourcePort = (ushort)((payload[offset] << 8) | payload[offset + 1]);
            offset += 2;

            // Level Value: 16 bit word (big-endian)
            entry.LevelValue = (ushort)((payload[offset] << 8) | payload[offset + 1]);
            offset += 2;

            reply.Levels.Add(entry);
        }

        return reply;
    }

    public override string ToString()
    {
        return $"Crosspoint Level Status: {Levels.Count} level(s)";
    }
}
